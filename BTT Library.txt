/* ============================================================================
   BODY TRANSFORMATION TRACKER (BTT) — FULL LIBRARY (CLEAN / WHOLE)

   This version includes the requested edits:

   ✅ Gender initialization runs on BOTH player input AND AI output.
   ✅ Gender detection is now IDENTITY-ONLY (pattern-based), so it will NOT
      misfire on preference/partner mentions like "female and futanari".
      Example safe: "partners must be female and futanari" (ignored)
      Example identity: "You are ... a normal human male" (locks MALE)

   Everything else preserved:
   - Slots: head, hair, arms, legs, breasts, nipples, gut, penis, vagina, ass, tail, wings
   - ass merges anus + cheeks region terms
   - Femininity: -100..+100
   - Fertility/Virility: 0..100; independent; baseline + trait-unlock
   - Trait stacking & detection
   - Manual commands: /btthelp /bttadd /bttfem /bttfert /bttvir
   - Command targeting accepts ANY slot trigger word

============================================================================ */

/* ---------------------------- CONFIG: SLOTS ---------------------------- */

var BTT_SLOTS = [
  "head","hair","arms","legs",
  "breasts","nipples","gut",
  "penis","vagina",
  "ass",
  "tail","wings"
];

/* ------------------------- SLOT TRIGGERS ------------------------------- */

var BTT_SLOT_TRIGGERS = {
  head:    ["head","face","skull","jaw","eyes","mouth"],
  hair:    ["hair","locks","mane"],
  arms:    ["arm","arms","hand","hands","finger","fingers"],
  legs:    ["leg","legs","thigh","thighs","calf","calves","foot","feet"],
  breasts: ["breast","breasts","boobs","chest"],
  nipples: ["nipple","nipples","areola","areolae"],
  gut:     ["waist","belly","stomach","abdomen","gut"],
  penis:   ["penis","cock","dick","shaft","member","phallus"],
  vagina:  ["vagina","pussy","cunt","slit","sex"],
  ass:     ["ass","butt","cheek","cheeks","anus","asshole","rear","hole","sphincter"],
  tail:    ["tail"],
  wings:   ["wing","wings"]
};

/* -------------------------- TRAIT AXES -------------------------------- */

var BTT_TRAITS = {
  creature: [
    "human",
    "demonic","succubus","incubus","angelic","eldritch",
    "draconic","dragon",
    "reptilian","naga",
    "feline","cat",
    "canine","dog","wolf",
    "vulpine","fox",
    "bovine","equine","avian",
    "slime","ooze",
    "plant","fungal",
    "insectoid","arachnid",
    "furry","scaly","chitinous"
  ],

  material: [
    "flesh",
    "rubber","latex",
    "slime","gel","gelatinous",
    "crystal","glass","obsidian",
    "stone","metal",
    "wax","plastic",
    "silicone","leather",
    "fur","scales","chitin"
  ],

  texture: [
    "smooth","slick","sticky",
    "velvet","fuzzy","hairy",
    "scaled","ridged",
    "ribbed","knotted","barbed","spined",
    "porous","glossy","oily","wet","dry"
  ],

  sexual_function: [
    "fertile","virile",
    "lactating","milk-producing",
    "leaking","self-lubricating",
    "heat-cycling","estrus",
    "rutting",
    "cum-producing"
  ],

  morphology: [
    "prehensile",
    "split","bifurcated",
    "multi-chambered",
    "inflatable",
    "telescoping",
    "segmented",
    "tentacled",
    "coiled",
    "double","multiple",
    "barbed","ribbed","knotted","ringed","spaded",
    "extra-clit","extra-erogenous-zone"
  ],

  sensory: [
    "oversensitive","hypersensitive",
    "numb",
    "responsive",
    "erogenous","extra-erogenous",
    "tingly","throbbing"
  ],

  presentation: [
    "feminine","masculine","androgynous",
    "cute","monstrous",
    "sleek","bulky","dainty","imposing"
  ],

  sex_keywords: [
    "cock","pussy","penile","vaginal"
  ]
};

/* ---------------------- INTERNAL: FLATTEN TRAITS ------------------------ */

var BTT_ALL_TRAITS = (function(){
  var out = [];
  var seen = {};
  for(var axis in BTT_TRAITS){
    if(!BTT_TRAITS.hasOwnProperty(axis)) continue;
    for(var i=0;i<BTT_TRAITS[axis].length;i++){
      var t = String(BTT_TRAITS[axis][i]).toLowerCase();
      if(seen[t]) continue;
      seen[t] = true;
      out.push(t);
    }
  }
  return out;
})();

/* ----------------------------- HELPERS ---------------------------------- */

function BTT_clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

function BTT_escapeRegex(s){
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function BTT_wordMatch(text, word){
  var w = BTT_escapeRegex(String(word || "").toLowerCase());
  if(!w) return false;
  return new RegExp("\\b" + w + "\\b", "i").test(text);
}

function BTT_findAllWordPositions(textLower, wordLower){
  var w = BTT_escapeRegex(wordLower);
  var re = new RegExp("\\b" + w + "\\b", "gi");
  var m, out = [];
  while((m = re.exec(textLower)) !== null){
    out.push(m.index);
  }
  return out;
}

function BTT_nearbyMatch(textLower, triggerLower, traitLower, window){
  window = (typeof window === "number") ? window : 80;

  var idx = textLower.indexOf(triggerLower);
  if(idx === -1) return false;

  var start = Math.max(0, idx - window);
  var end   = Math.min(textLower.length, idx + window);
  var slice = textLower.slice(start, end);

  return BTT_wordMatch(slice, traitLower);
}

function BTT_splitClauses(text){
  return String(text || "")
    .split(/[.,;:!?]/g)
    .map(function(s){ return s.trim(); })
    .filter(function(s){ return s.length > 0; });
}

function BTT_lastSlotInClause(clauseLower){
  var bestSlot = null;
  var bestPos = -1;

  for(var i=0;i<BTT_SLOTS.length;i++){
    var slot = BTT_SLOTS[i];
    var triggers = BTT_SLOT_TRIGGERS[slot] || [];
    for(var t=0;t<triggers.length;t++){
      var trig = String(triggers[t]).toLowerCase();
      var positions = BTT_findAllWordPositions(clauseLower, trig);
      if(positions.length){
        var pos = positions[positions.length - 1];
        if(pos > bestPos){
          bestPos = pos;
          bestSlot = slot;
        }
      }
    }
  }
  return bestSlot;
}

/* Target may be slot name OR any trigger word for that slot */
function BTT_resolveTargetToSlot(targetRaw){
  var tok = String(targetRaw || "").trim().toLowerCase();
  if(!tok) return null;

  if(BTT_SLOTS.indexOf(tok) !== -1) return tok;

  for(var i=0;i<BTT_SLOTS.length;i++){
    var slot = BTT_SLOTS[i];
    var triggers = BTT_SLOT_TRIGGERS[slot] || [];
    for(var t=0;t<triggers.length;t++){
      if(String(triggers[t]).toLowerCase() === tok) return slot;
    }
  }
  return null;
}

/* ------------------------- NARRATIVE FILTER ----------------------------- */

function BTT_isNarrative(text){
  if(!text || typeof text !== "string") return false;

  if(text.indexOf("Available Classes") !== -1) return false;
  if(text.indexOf("Resources:") !== -1) return false;
  if(text.indexOf("Stats:") !== -1) return false;

  var listMarks = (text.match(/^\s*[-*•]\s+/gm) || []).length;
  if(listMarks >= 3) return false;

  return true;
}

/* ------------------------------ STATE ----------------------------------- */

function BTT_ensureState(){
  if(typeof state === "undefined" || !state) state = {};
  if(!state.BTT) state.BTT = {};
  if(!state.BTT.characters) state.BTT.characters = {};
  if(typeof state.BTT._showHelp === "undefined") state.BTT._showHelp = false;
}

function BTT_newSlotState(){
  return { traits:[], femininity:0, fertility:null, virility:null };
}

function BTT_initReproBySlot(slotState, slot){
  if(!slotState || !slot) return;
  if(slot === "penis" && slotState.virility === null) slotState.virility = 20;
  if(slot === "vagina" && slotState.fertility === null) slotState.fertility = 20;
  if(slot === "ass" && slotState.fertility === null) slotState.fertility = 0;
}

function BTT_applyReproFromTraits(slotState){
  if(!slotState || !slotState.traits) return;
  var has = function(t){ return slotState.traits.indexOf(t) !== -1; };

  if((has("pussy") || has("vaginal")) && slotState.fertility === null) slotState.fertility = 20;
  if((has("cock") || has("penile")) && slotState.virility === null) slotState.virility = 20;
}

function BTT_ensureCharacter(characterName){
  BTT_ensureState();
  if(!characterName) characterName = "Player";

  if(!state.BTT.characters[characterName]){
    state.BTT.characters[characterName] = { __initialized:false, gender:"" };
    for(var i=0;i<BTT_SLOTS.length;i++){
      var slot = BTT_SLOTS[i];
      state.BTT.characters[characterName][slot] = BTT_newSlotState();
      BTT_initReproBySlot(state.BTT.characters[characterName][slot], slot);
    }
  } else {
    for(var j=0;j<BTT_SLOTS.length;j++){
      var sl = BTT_SLOTS[j];
      if(!state.BTT.characters[characterName][sl]){
        state.BTT.characters[characterName][sl] = BTT_newSlotState();
      }
      BTT_initReproBySlot(state.BTT.characters[characterName][sl], sl);
    }
    if(typeof state.BTT.characters[characterName].__initialized === "undefined"){
      state.BTT.characters[characterName].__initialized = false;
    }
    if(typeof state.BTT.characters[characterName].gender === "undefined"){
      state.BTT.characters[characterName].gender = "";
    }
  }

  return state.BTT.characters[characterName];
}

/* ----------------------- STORY CARDS ----------------------------------- */

function BTT_hasStoryCards(){
  return (typeof storyCards !== "undefined" && storyCards);
}

function BTT_slotTitle(characterName, slot){
  return "BTT | " + characterName + " | " + slot;
}

function BTT_getOrCreateSlotCard(characterName, slot){
  if(!BTT_hasStoryCards()) return null;

  var title = BTT_slotTitle(characterName, slot);
  var sc = storyCards.find(function(c){ return c.title === title; });

  if(!sc){
    addStoryCard(title, "Blank", "Anatomy");
    sc = storyCards.find(function(c){ return c.title === title; });
    if(sc){
      sc.keys = (BTT_SLOT_TRIGGERS[slot] || []).join(", ");
      sc.entry = characterName.toUpperCase() + " ANATOMY — " + slot.toUpperCase() + "\n\nTraits:\n - (none)\n";
    }
  }
  return sc;
}

function BTT_writeSlot(characterName, slot){
  if(!BTT_hasStoryCards()) return;

  var ch = BTT_ensureCharacter(characterName);
  var s = ch[slot];
  if(!s || !s.traits || !s.traits.length) return;

  BTT_initReproBySlot(s, slot);
  BTT_applyReproFromTraits(s);

  var sc = BTT_getOrCreateSlotCard(characterName, slot);
  if(!sc) return;

  var lines = [];
  lines.push(characterName.toUpperCase() + " ANATOMY — " + slot.toUpperCase());
  lines.push("");
  lines.push("Traits:");
  for(var i=0;i<s.traits.length;i++) lines.push(" - " + s.traits[i]);
  lines.push("");
  lines.push("Femininity: " + s.femininity + "  (range -100..+100; 0 = androgynous)");
  if(s.fertility !== null) lines.push("Fertility: " + s.fertility + "/100");
  if(s.virility !== null) lines.push("Virility: " + s.virility + "/100");

  sc.entry = lines.join("\n");
}

function BTT_writeAll(characterName){
  var ch = BTT_ensureCharacter(characterName);
  for(var i=0;i<BTT_SLOTS.length;i++){
    var slot = BTT_SLOTS[i];
    if(ch[slot] && ch[slot].traits && ch[slot].traits.length){
      BTT_writeSlot(characterName, slot);
    }
  }
}

/* ----------------------- APPLY TRAITS ---------------------------------- */

function BTT_applyTrait(characterName, slot, trait){
  if(!characterName) characterName = "Player";
  if(!slot || BTT_SLOTS.indexOf(slot) === -1) return;

  var ch = BTT_ensureCharacter(characterName);
  var s = ch[slot];

  var t = String(trait || "").trim().toLowerCase();
  if(!t) return;
  if(!/^[a-z0-9][a-z0-9-]*$/.test(t)) return;

  if(s.traits.indexOf(t) === -1) s.traits.push(t);

  BTT_initReproBySlot(s, slot);
  BTT_applyReproFromTraits(s);
  BTT_writeSlot(characterName, slot);
}

function BTT_applyTraits(characterName, slot, traits){
  if(!traits || !traits.length) return;
  for(var i=0;i<traits.length;i++){
    BTT_applyTrait(characterName, slot, traits[i]);
  }
}

/* ----------------------- MODIFY STATS ---------------------------------- */

function BTT_modifyFemininity(characterName, slot, delta){
  var ch = BTT_ensureCharacter(characterName);
  delta = Number(delta) || 0;

  if(slot){
    var s = ch[slot];
    if(s && typeof s.femininity === "number"){
      s.femininity = BTT_clamp(s.femininity + delta, -100, 100);
      BTT_writeSlot(characterName, slot);
    }
  } else {
    var d = Math.round(delta / 2);
    for(var i=0;i<BTT_SLOTS.length;i++){
      var sl = BTT_SLOTS[i];
      var ss = ch[sl];
      if(ss && typeof ss.femininity === "number"){
        ss.femininity = BTT_clamp(ss.femininity + d, -100, 100);
      }
    }
    BTT_writeAll(characterName);
  }
}

function BTT_modifyRepro(characterName, slot, stat, delta){
  var ch = BTT_ensureCharacter(characterName);
  delta = Number(delta) || 0;
  if(stat !== "fertility" && stat !== "virility") return;

  if(slot){
    var s = ch[slot];
    if(s && typeof s[stat] === "number"){
      s[stat] = BTT_clamp(s[stat] + delta, 0, 100);
      BTT_writeSlot(characterName, slot);
    }
  } else {
    var d = Math.round(delta / 2);
    for(var i=0;i<BTT_SLOTS.length;i++){
      var sl = BTT_SLOTS[i];
      var ss = ch[sl];
      if(ss && typeof ss[stat] === "number"){
        ss[stat] = BTT_clamp(ss[stat] + d, 0, 100);
      }
    }
    BTT_writeAll(characterName);
  }
}

/* ----------------------- GENDER DETECTION (IDENTITY-ONLY) ---------------- */

function BTT_sanitizeForGender(text){
  var s = String(text || "");
  s = s.replace(/\/btt[a-z]+\b[^\n\r]*/ig, " "); // remove btt commands
  s = s.replace(/[\/|]/g, " ");
  s = s.replace(/\s+/g, " ").trim();
  if(s.length > 2000) s = s.slice(0, 2000); // keep enough for scenario prompt, but not infinite
  return s;
}

// Identity-only patterns (preference/partner mentions won't match these)
var BTT_GENDER_IDENTITY_PATTERNS = {
  male: [
    /\byou are (?:a |an )?male\b/i,
    /\byou are (?:a |an )?man\b/i,
    /\bi am (?:a |an )?male\b/i,
    /\bi am (?:a |an )?man\b/i,
    /\ba (?:normal )?human male\b/i,
    /\ba man stares back at you\b/i,
    /\bhis\b/i // used only as fallback in some prompts; see detector for ordering
  ],
  female: [
    /\byou are (?:a |an )?female\b/i,
    /\byou are (?:a |an )?woman\b/i,
    /\bi am (?:a |an )?female\b/i,
    /\bi am (?:a |an )?woman\b/i,
    /\ba (?:normal )?human female\b/i,
    /\ba woman stares back at you\b/i,
    /\bher\b/i
  ],
  futa: [
    /\byou are (?:a |an )?futa(?:nari)?\b/i,
    /\bi am (?:a |an )?futa(?:nari)?\b/i,
    /\b(?:a |an )?futanari\b/i
  ],
  herm: [
    /\byou are (?:a |an )?herm(?:aphrodite)?\b/i,
    /\bi am (?:a |an )?herm(?:aphrodite)?\b/i,
    /\bhermaphrodite\b/i
  ],
  femboy: [
    /\byou are (?:a |an )?femboy\b/i,
    /\bi am (?:a |an )?femboy\b/i
  ]
};

/* Deterministic identity-only gender detection:
   - Uses strict identity phrasing first.
   - Pronoun-only patterns (his/her) are treated as LOW-CONFIDENCE fallbacks
     and only apply if no strict identity matches were found.
*/
function BTT_detectGenderFromIdentity(text){
  var s = BTT_sanitizeForGender(text);
  if(!s) return null;

  // Strict pass (no pronoun-only matches)
  var strictOrder = ["male","female","futa","herm","femboy"];
  for(var oi=0; oi<strictOrder.length; oi++){
    var g = strictOrder[oi];
    var patterns = BTT_GENDER_IDENTITY_PATTERNS[g] || [];
    for(var i=0;i<patterns.length;i++){
      var re = patterns[i];
      // Skip pronoun-only fallback in strict pass
      if(String(re).indexOf("\\bhis\\b") !== -1) continue;
      if(String(re).indexOf("\\bher\\b") !== -1) continue;
      if(re.test(s)) return g;
    }
  }

  // Fallback pass (pronouns) — only if nothing else matched
  if(/\bhis\b/i.test(s) && !/\bher\b/i.test(s)) return "male";
  if(/\bher\b/i.test(s) && !/\bhis\b/i.test(s)) return "female";

  return null;
}

function BTT_genderFemBaseline(g){
  if(g === "male") return -50;
  if(g === "female") return 50;
  if(g === "herm") return 0;
  if(g === "futa") return 25;
  if(g === "femboy") return -25;
  return 0;
}

function BTT_generateBaseline(characterName, gender){
  var ch = BTT_ensureCharacter(characterName);

  var femBase = BTT_genderFemBaseline(gender);
  for(var i=0;i<BTT_SLOTS.length;i++){
    ch[BTT_SLOTS[i]].femininity = femBase;
  }

  // nipples default regardless of gender
  var baseSlots = ["head","hair","arms","legs","gut","ass","nipples"];
  for(var b=0;b<baseSlots.length;b++){
    BTT_applyTrait(characterName, baseSlots[b], "human");
  }

  if(gender === "male"){
    BTT_applyTrait(characterName, "penis", "human");
  } else if(gender === "female"){
    BTT_applyTrait(characterName, "breasts", "human");
    BTT_applyTrait(characterName, "vagina", "human");
  } else if(gender === "futa"){
    BTT_applyTrait(characterName, "breasts", "human");
    BTT_applyTrait(characterName, "penis", "human");
    BTT_applyTrait(characterName, "vagina", "human");
  } else if(gender === "herm"){
    BTT_applyTrait(characterName, "penis", "human");
    BTT_applyTrait(characterName, "vagina", "human");
  } else if(gender === "femboy"){
    BTT_applyTrait(characterName, "penis", "human");
  }

  BTT_writeAll(characterName);
}

/* Try initialize from ANY text source (player input OR AI output). */
function BTT_tryInitializeFromText(text){
  var ch = BTT_ensureCharacter("Player");
  if(ch.__initialized) return;

  var g = BTT_detectGenderFromIdentity(text);
  if(g){
    BTT_generateBaseline("Player", g);
    ch.gender = g;
    ch.__initialized = true;
  }
}

/* ----------------------- HELP TEXT + COMMANDS --------------------------- */

function BTT_helpText(){
  return [
    "=== BODY TRANSFORMATION TRACKER (BTT) HELP ===",
    "",
    "BTT tracks transformations per body-part slot via Story Cards:",
    "  BTT | Player | <slot>",
    "",
    "SLOTS:",
    "- head, hair, arms, legs, breasts, nipples, gut, penis, vagina, ass, tail, wings",
    "  (ass includes anus + cheeks + ass-region terms)",
    "",
    "STATS:",
    "- Femininity: -100..+100 (0 = androgynous)",
    "- Fertility: 0..100 (if applicable)",
    "- Virility:  0..100 (if applicable)",
    "",
    "BASELINES:",
    "- penis starts Virility 20",
    "- vagina starts Fertility 20",
    "- ass starts Fertility 0",
    "- adding traits can unlock stats:",
    "    pussy/vaginal => Fertility 20 if missing",
    "    cock/penile   => Virility 20 if missing",
    "",
    "COMMANDS:",
    "/btthelp",
    "/bttadd <target> <trait1,trait2,...>",
    "/bttfem [target] +/-N",
    "/bttfert [target] +/-N",
    "/bttvir [target] +/-N",
    "",
    "TARGETING:",
    "- <target> can be a slot name OR any trigger word for that slot.",
    "  Example: /bttadd asshole slime,demonic  -> targets ASS slot",
    "============================================="
  ].join("\n");
}

function BTT_handleManualCommands(text, characterName){
  if(!text || typeof text !== "string") return text;
  if(!characterName) characterName = "Player";

  BTT_ensureCharacter(characterName);

  text = text.replace(/\/btthelp\b/ig, function(){
    state.BTT._showHelp = true;
    return "";
  });

  text = text.replace(/\/bttadd\s+([^\s]+)\s+([^\n\r]+)/ig, function(_m, targetRaw, traitsRaw){
    var slot = BTT_resolveTargetToSlot(targetRaw);
    if(!slot) return "";

    var parts = String(traitsRaw || "")
      .split(",")
      .map(function(s){ return s.trim().toLowerCase(); })
      .filter(function(s){ return !!s; });

    for(var i=0;i<parts.length;i++){
      BTT_applyTrait(characterName, slot, parts[i]);
    }
    return "";
  });

  function parseTargetAndDelta(arg1, arg2){
    if(typeof arg2 === "undefined" || arg2 === null){
      var d0 = Number(arg1);
      if(!isFinite(d0)) return null;
      return { slot:null, delta:d0 };
    }
    var slot = BTT_resolveTargetToSlot(arg1);
    if(!slot) return null;
    var d = Number(arg2);
    if(!isFinite(d)) return null;
    return { slot:slot, delta:d };
  }

  text = text.replace(/\/bttfem\s+([^\s]+)(?:\s+([+-]?\d+))?/ig, function(_m, a, b){
    var parsed = parseTargetAndDelta(a, b);
    if(!parsed) return "";
    BTT_modifyFemininity(characterName, parsed.slot, parsed.delta);
    return "";
  });

  text = text.replace(/\/bttfert\s+([^\s]+)(?:\s+([+-]?\d+))?/ig, function(_m, a, b){
    var parsed = parseTargetAndDelta(a, b);
    if(!parsed) return "";
    BTT_modifyRepro(characterName, parsed.slot, "fertility", parsed.delta);
    return "";
  });

  text = text.replace(/\/bttvir\s+([^\s]+)(?:\s+([+-]?\d+))?/ig, function(_m, a, b){
    var parsed = parseTargetAndDelta(a, b);
    if(!parsed) return "";
    BTT_modifyRepro(characterName, parsed.slot, "virility", parsed.delta);
    return "";
  });

  return text;
}

/* ----------------------- DETECTION CORE -------------------------------- */

function BTT_detectTransformations(text, characterName){
  if(!text || typeof text !== "string") return;
  if(!characterName) characterName = "Player";
  if(!BTT_isNarrative(text)) return;

  var lower = text.toLowerCase();

  // Pass A: cock/pussy clause targeting
  var clauses = BTT_splitClauses(lower);
  for(var ci=0; ci<clauses.length; ci++){
    var clause = clauses[ci];
    if(!clause) continue;

    var lastSlot = BTT_lastSlotInClause(clause);

    if(BTT_wordMatch(clause, "cock")){
      if(lastSlot) BTT_applyTrait(characterName, lastSlot, "cock");
      else BTT_applyTrait(characterName, "penis", "human");
    }

    if(BTT_wordMatch(clause, "pussy")){
      if(lastSlot) BTT_applyTrait(characterName, lastSlot, "pussy");
      else BTT_applyTrait(characterName, "vagina", "human");
    }
  }

  // Pass B: general trait detection
  for(var i=0;i<BTT_SLOTS.length;i++){
    var slot = BTT_SLOTS[i];
    var triggers = BTT_SLOT_TRIGGERS[slot] || [];
    if(!triggers.length) continue;

    for(var t=0;t<triggers.length;t++){
      var trig = String(triggers[t]).toLowerCase();
      if(!trig) continue;

      if(!BTT_wordMatch(lower, trig)) continue;

      var found = [];
      for(var j=0;j<BTT_ALL_TRAITS.length;j++){
        var trait = BTT_ALL_TRAITS[j];
        if(BTT_nearbyMatch(lower, trig, trait, 80)){
          found.push(trait);
        }
      }

      if(found.length){
        BTT_applyTraits(characterName, slot, found);
      }
    }
  }
}

/* ---------------------------- HOOKS ------------------------------------ */

function onInput_BTT(text){
  // Initialize from player input too (but not exclusively)
  BTT_tryInitializeFromText(text);

  // Strip commands from visible text
  text = BTT_handleManualCommands(text, "Player");

  // Transform detection on player input
  BTT_detectTransformations(text, "Player");

  return text;
}

function onContext_BTT(text){
  return text;
}

function onOutput_BTT(text){
  // Initialize from AI output (scenario prompt)
  BTT_tryInitializeFromText(text);

  // Transform detection on AI output
  BTT_detectTransformations(text, "Player");

  // Update Story Cards
  BTT_writeAll("Player");

  // Show help if requested
  if(state && state.BTT && state.BTT._showHelp){
    state.BTT._showHelp = false;
    text = BTT_helpText() + "\n\n" + text;
  }

  return text;
}

/* ============================================================================
   END BTT LIBRARY
============================================================================ */
